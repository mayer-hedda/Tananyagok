---------------------------------------------BEVEZETÉS ---------------------------------------------

java létrehozói (5):		> James Gosling
				> Patrick Naughton
				> Chris Warth
				> Ed Frank
				> Mike Sheridan


Úgy tervezték, hogy minden op. rendszeren fusson → a programot java környezetben futtatjuk


JRE - Java Runtime Environment → Oracle keretrendszere
JDK - Java Development Kit → fejlesztői környezet
A JDK tartalmazza a JRE-t.


A java nyelv:		> szigorúan osztályok halmaza
			> kis és nagybetű érzékeny
			> minden utasítást pontosvesszővel zárunk



--------------------------------------------- HELLO WORLD -------------------------------------------

class Test {
	public static void main(String[] args) {
		System.out.println("Hello World!");
	} 
}


A program elemzése:

	> Blokkokat kapcsoszárójellel tagoljuk.
	> A blokkok egymásba ágyazhatóak.
	> Van fejrészük → itt adjuk meg, hogy mire való az adott blokk.
	> A tevékenységeket függvényekben valósítjuk meg → Metódus
	> Minden java program tartalmaz egy main metódust
	> Main módosítói: 		
		- public: biztosítja, hogy induláskor a metódust elérje az op. rendszer
		- static: biztosítja, hogy az osztály példányosítása nélkü is elérjük a metódust
		- void: a metódus nem rendelkezik visszatérési értékkel
		- bemenő paraméterek :  String tömb args néven


System osztály:

	> A javában használt osztályokat szükséges csoportosítani.
	> Összefüggő osztálokat csomagokban tároljuk.
	> Ha szeretnénk használni egy osztályt, akkor importálni kell a csomagját
	> A System osztály a java.lang csomagból származik → ezt nem kötelező importálni



-------------------------------------------- MEGJEGYZÉSEK ------------------------------------------

// egysoros komment


/*
több
soros
kommet
*/



----------------------------------------------- KIVITEL ----------------------------------------------

A System osztály 2 metódusát tudjuk ehhez hasznáni:	

	> print() → nem teszt sortörést a végére
	> println() → van sortörés a végén


Kiírások:

	> System.out.println("ElsőMásodik");	→ 	ElsőMásodik
	> System.out.println("@!+=");		→ 	@!+=
	> System.out.println("1234");		→ 	1234
	> System.out.println(1234);			→ 	1234
	> System.out.println(3 + 2);		→ 	5



-------------------------------------- KÜLÖNLEGES KARAKTEREK -------------------------------------

Különleges karakterek = escape szekvenciák

	> Ha egy karakternek a speciális jelentését szeretnénk használni, akkor azt egy fordított 	
	   per jellel tehetjük meg.
		- Sortörés 	→ 	\n
		- Tabulátor 	→	\t

	> Vannak eleve speciális jelentésű karakterek a java nyelvben (pl. az idézője), ezekhez is 
	   tartoznak escape szekvenciák.
		- Idézőjel egy szövegen belül	→ 	\"


Escape szekvenciák:
	
	> \uxxxx	→ 	hexadecimális UNICODE karakter (xxxx)
		- Unicode karakterek: 	http://www.unicode.org/charts/PDF/U0080.pdf
	> \'		→ 	aposztróf
	> \"		→	 idézőjel
	> \\		→ 	fordított per jel
	> \r		→	kocsi vissza (a kiírás a sor elején folytatódik
	> \n		→ 	új sor
	> \f		→ 	lapdobás
	> \t		→ 	tabulátor
	> \b		→ 	visszatörlés (előtte lévő karaktert törli)



------------------------------------------- ADATTÍPÚSOK --------------------------------------------

	> Memóriában tároljuk az adatokat, ezek lehetnek:
		- Egész számok
		- Valós számok
		- Karakterek
		- Karaktersorozatok

	> Ezekre változóként hivatkozunk és használatuk előtt deklarálni kell. Iyenkor megadjuk a 
	   változónak az adattípúsát, hogy tudja a program, hogy mekkora memóriahelyet kell 
	   lefoglalnia a változónak. Utána erre a memóriahelyre értéket helyezünk.
	   

Egész típúsok:	

	> byte  	→ 	1 byte (-128  –  127)
	> short  	→	2 bytes (-32768  –  32767)
	> int		→	4 bytes (-2147483648  –  2147483647)
	> long		→	8 bytes (-9223372036854775808  –  9223372036854775807)


Valós típúsok:
	
	> float	→ 	4 bytes (1.4e-45  –  3.4028235e+38)
		- float a = 3.4f;

	> double	→ 	8 bytes (4.9e-324  –  1.7976931348623157e+308)
		- double b = 3.4d;
		- elhagyható a d betű → double b = 3.4;


Java karakterek:
	
	> char		→ 	2 bytes
	> Aposztrófok között deklaráljuk 	→ 	char c = 'c';


Logikai típús:

	> boolean	→ 	1 byte
	> Értéke lehet true és false
	> boolean van = true;


A primitív típusok csomagolóosztályai:

	> Javában nem minden objektum, például a primitív adattípusok sem
	> A javában minden típus előjeles (signed), nincsen előjel nélküli (unsigned)
	> Minden primitív típus rendelkezik egy nekik megfelelő csomagolóosztállyal (burkoló 
	   osztállyal)

		- boolean	→	Boolean
		- char		→ 	Character
		- byte		→ 	Byte
		- short	→ 	Short
		- int		→	Integer
		- long		→ 	Long
		- float		→	Float
		- double	→	Double


Egyenlőség:

	> Primitív adattípusokat össze tudunk hasonlítani dupla egyenlőségjellel:
		-	double a = 3.0;
			double b = 3.0;
			System.out.println(a == b);
		- Output:	 true

	> De ha osztályokat használunk, akkor nem működik, ilyenkor az osztály equals() 
	   metódusát használjuk:
		- 	Double a = 3.0;
			Double b = 3.0;
			System.out.println(a.equals(b));
		- Output: 	true


Típusok mérete és határa:

	> Maximum értékek:
		- Byte.MAX_VALUE
		- Short.MAX_VALUE
		- Integer.MAX_VALUE
		- Long.MAX_VALUE

	> Minimum értékek:
		- Byte.MIN_VALUE
		- Short.MIN_VALUE
		- Integer.MIN_VALUE
		- Long.MIN_VALUE

	> Hány biten tároljuk az adott típust:
		- Byte.SIZE
		- Short.SIZE
		- Integer.SIZE
		- Long.SIZE

	> A printf metódussal tizedestört formában is kiirathatóak a lebegőpontos számok:
		- System.out.printf("%f\n", Double.MAX_VALUE);


Típusok konverziója szélesítéssel:
	
	> Angolul: Automatic Type Promotion
	> Ha van egy kisebb számokat tárolni képes változónk, annak értéke eltárolható egy nagyobb 
	   értékek tárolására képes változóban. Ezt nevezzük szélesítésnek. Fordítva nem lehetséges!
		-	byte a = 35;
			int b = a;
	> Lehetséges szélesítések:
		- byte 		→ 	short, int, long, float, double
		- short 	→ 	int, long, float, double
		- char 	→ 	int, long, float, double
		- int 		→ 	long, float, double
		- long 		→ 	float double
		- float 	→ 	double


Típusok konverziója szűkítéssel:

	> Ezt csak típuskényszerítéssel / kasztolással tudjuk megtenni
		-	short a = 3;
			byte b = (byte) a;
	> Lehetséges szűkítések:
		- short  	→ 	byte, char
		- char 	→ 	byte, short
		- int 		→ 	byte, short, char
		- long 		→ 	byte, short, char, int
		- float 	→ 	byte, short, char, int, long
		- double 	→ 	byte, short, char, int, long, float


Literális:
	
	> A literális egy olyan állandó, aminek nincs neve. Literális például a „3”, az „a” betű, a „/” jel, 
	   bármi.
	> A szám literálisokat csak úgy leírjuk, a karakterlitárálisokat aosztrófok közé tesszük, a 
	   karaktersorozat literálisokat pedig idézőjelek közé tesszük a Java nyelvben.



----------------------------------- JAVA VÁLTOZÓK ÉS ÁLLANDÓK -----------------------------------

A változók elnevezése:
	
	> A változókat használat előtt deklaráni kell:
		-	double fizetes;
			double _fizetes;
			int fizetes;
			int $fizetes;
			long fizetes;
			boolean kesz;
	> Egy változónév nem kezdődhet:		
		- számmal
		- százalékjellel
		- kettőskereszttel


A java állandói:

	> Literális állandók (korábbiakban volt róla szó)
	> Nevesített állandók:
		- Vállaljuk, hogy a program további részében nem fog megváltozni a változónak az értéke
		- Az állandókat nagybetűvel szokás írni, hogy könnyen megkülönböztethetőek legyenek
		-	final int ALAPFIZETES = 200000;
			System.out.println(ALAPFIZETES);



--------------------------------------------- ÉRTÉKADÁS ---------------------------------------------

	> Egy db egyenlőséggel végezzük az értékadást.
	> Az egyenlőségjel bal oldalán lévő változó felveszi a jobb oldalon lévő értéket


Számállandók a jobb oldalon:

	> float a = 3f;
	> float b = 3;
	> double c = 3.;


Változók a jobb oldalon:

	> float d = a;


Kifejezés a jobb oldalon:

	> float e = (b + c) * 3;
	> A kifejezés operátorokat és operandusokat tartalmaz
		- Operandusok: a változók / számok amikke dolgozunk ("b", "c" és "3")
		- Operátorok: az operandusokkal végzett műveletek ("()", "+" és "*")
	> Értékadásnál az egyenlőségjel bal oldalán nem szerepelhet kifejezés


Egész és valós számok:

	>	double a = 1 / 2;
		System.out.println(a);
	> Output:	0
	> Mivel az értékadás jobb oldalán csak egész számok szerepelnek, ezért a tört részek elvesznek.
	> Ha legalább az egyik számot valós típusúvá tesszük, akkr az eredmény 0.5 lesz
	    
	    	- Egyik szám kiegészítése tizedestörtre:
			 	double a = 1 / 2.0;
				System.out.prinln(a);

		- De a nulla el is hagyható:
				double b = 1 / 2.;
				System.out.println(b);

		- Vagy az egyik szám mögé írjuk az "f" vagy "d" betűt:
			 	double c = 1 / 2f;
				System.out.println(c);



---------------------------------------- FORMÁZOTT KIVITEL ----------------------------------------

















